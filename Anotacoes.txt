id category: 68b7924af5796311d51ded69

{
  "name": "Notebook Dell Inspiron 15",
  "slug": "notebook-dell-inspiron-15",
  "description": "i7, 16GB RAM, SSD 512GB",
  "price": 3500.00,
  "sku": "NB-DELL-INS15",
  "barcode": "7891234567890",
  "categoryId": "68b7924af5796311d51ded69",
  "images": ["https://example.com/img1.jpg"],
  "stockQuantity": 10,
  "stockMin": 2,
  "status": "active"
}
 id_product 68b79c938c08ff21a46f138c

Entrada de estoque (in)
{
  "productId": "68b79c938c08ff21a46f138c",
  "type": "in",
  "quantity": 0,
  "reason": "Reposição do fornecedor",
  "ref": "PO-12345"
}

Saída de estoque (out)
{
  "productId": "68b79c938c08ff21a46f138c",
  "type": "out",
  "quantity": 9999,
  "reason": "Venda balcão",
  "ref": "SALE-987"
}

Ajuste (adjustment)
{
  "ProductId": "68b79c938c08ff21a46f138c",
  "Type": "adjustment",
  "Quantity": -2,
  "reason": "Perda/avaria",
  "ref": "AUD-2025-09"
}
Seguir a bússola do README e do development-plan
→ Nunca inventar requisito. Se não está no README ou no plano, não é obrigatório.
→ O que não está lá só entra como ponto extra se você pedir.

Um passo de cada vez
→ Eu só avanço depois que você testa/confirma.
→ Sempre mando arquivos inteiros prontos pra colar no VSCode (sem trechos soltos).

Commits e ADRs sempre
→ Uso Conventional Commits.
→ Cada decisão relevante vira um ADR (docs/adr/00NN-*.md).

Sem adivinhação
→ Se não sei o schema, peço Swagger.
→ Se não sei se precisa de página nova, pergunto
→ Se preciso criar um arquivo peço os dados e infomrações não chuto nem deduzo nada
→ Olho o README/plan primeiro.

Explicação + Solução
→ Explico o conceito apenas quando voce perguntar (ex.: “slug”, “boilerplate”).
→ Depois já entrego o que você cola no código (serviço, page, config).
→ Ajustes pontuais eu deixo bem claro qual arquivo e quais linhas alterar mostrando o antes e depois do trecho.
→ Comandos que forem executados no terminal eu explico que qual pasta ele deve ser executado mando o caminho duvidas pede a tree dos arquivos

Escalabilidade
→ Mostro quando algo é suficiente pro desafio (mínimo exigido).
→ Também sinalizo quando pode virar melhoria futura (extras)



